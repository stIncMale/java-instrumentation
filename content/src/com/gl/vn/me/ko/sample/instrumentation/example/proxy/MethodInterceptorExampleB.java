package com.gl.vn.me.ko.sample.instrumentation.example.proxy;

import java.lang.reflect.Method;
import java.math.BigDecimal;
import java.text.NumberFormat;
import net.sf.cglib.proxy.MethodProxy;
import org.apache.log4j.Logger;
import com.gl.vn.me.ko.sample.instrumentation.env.misc.LogHelper;
import com.gl.vn.me.ko.sample.instrumentation.example.util.cglib.MethodInterceptor;

/**
 * This class is a method interceptor that can be used as a callback for creation of CGLib proxies. See {@link #intercept(Object, Method, Object[], MethodProxy)} method for details.
 * <p/>
 * Instantiability: explicit instantiation is forbidden; singleton.<br/>
 * Mutability: immutable.<br/>
 * Thread safety: thread-safe.
 * 
 * @author Valentin Kovalenko
 */
final class MethodInterceptorExampleB implements MethodInterceptor {
	private final static Logger LOGGER;
	/**
	 * The only possible instance of the class per its class loader.
	 */
	public final static MethodInterceptorExampleB INSTANCE;
	static {
		LOGGER = Logger.getLogger(MethodInterceptorExampleB.class);
		INSTANCE = new MethodInterceptorExampleB();
	}

	private final static Object invokeInterceptedMethod(final Object enhancedObject, final Method method, final Object[] methodArgs, final MethodProxy methodProxy) throws Throwable {
		final Object result = methodProxy.invokeSuper(enhancedObject, methodArgs);
		return result;
	}

	private MethodInterceptorExampleB() {
	}

	/**
	 * Invokes the original method of proxied class, prints some information into log and negates the value returned from the original
	 * method if this value is of type {@code java.math.BigDecimal}.
	 * 
	 * @return
	 *         Result of the original method invocation or negated value of the original result if it's of type {@code java.math.BigDecimal}.
	 */
	public final Object intercept(final Object enhancedObject, final Method method, final Object[] methodArgs, final MethodProxy methodProxy) throws Throwable {
		final NumberFormat numberFormat = LogHelper.getNumberFormat();
		final String methodName = enhancedObject.getClass().getSuperclass().getCanonicalName() + "." + method.getName();
		final Object returnValueFromInterceptedMethod = invokeInterceptedMethod(enhancedObject, method, methodArgs, methodProxy);
		final boolean returnValueIsBigDecimal = returnValueFromInterceptedMethod instanceof BigDecimal;// note that the check here is for BigDecimal class, not for the proxy class generated by CGLib.
																										// This is because only BigDecimal objects created in the class
																										// 'com/gl/vn/me/ko/sample/instrumentation/example/ExampleB' were proxied
																										// (see ClassTransformerExampleB). And if the method of such a proxy object returns BigDecimal,
																										// it means the returned object is really instance of BigDecimal and not a proxy class,
																										// because bodies of any methods of BigDecimal class were not modified.
		final String stringRepresentationOfReturnValue = returnValueIsBigDecimal ? numberFormat.format(returnValueFromInterceptedMethod) : returnValueFromInterceptedMethod.toString();
		if (LOGGER.isInfoEnabled()) {
			final String commonMessage = "The return value of the method '" + methodName + "' is '" + stringRepresentationOfReturnValue + "'";
			if (returnValueIsBigDecimal) {
				LOGGER.info(commonMessage + " and it's a BigDecimal. Return it with the opposite sign");
			} else {
				LOGGER.info(commonMessage);
			}
		}
		final Object result = returnValueIsBigDecimal ? ((BigDecimal)returnValueFromInterceptedMethod).negate() : returnValueFromInterceptedMethod;
		return result;
	}
}